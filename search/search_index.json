{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Pycrdt is a Python CRDT library that provides bindings for Yrs, the Rust port of the Yjs framework.</p> <p>Conflict-free Replicated Data Types (CRDTs) allow creating shared documents that can automatically merge changes made concurrently on different \"copies\" of the data. When the data lives on different machines, they make it possible to build distributed systems that work with local data, leaving the synchronization and conflict resolution with remote data to the CRDT algorithm, which ensures that all data replicas eventually converge to the same state.</p> <p>Pycrdt is an alternative to Ypy. Their architectures differ in that pycrdt is a mixed Python/Rust project, while Ypy is Rust-only. This probably gives Ypy a performance gain, at the cost of complexity. Pycrdt is more Pythonic and its code base probably easier to understand and maintain. For more information, see the following GitHub issues:</p> <ul> <li>Move pycrdt to jupyter-server</li> <li>New Python bindings for Yrs</li> </ul>"},{"location":"api_reference/","title":"API reference","text":""},{"location":"api_reference/#pycrdt.Array","title":"<code>Array</code>","text":"<p>               Bases: <code>BaseType</code></p> <p>A collection used to store data in an indexed sequence structure, similar to a Python <code>list</code>.</p>"},{"location":"api_reference/#pycrdt.Array.doc","title":"<code>doc: Doc</code>  <code>property</code>","text":"<p>The document this shared type belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Not integrated in a document yet.</p>"},{"location":"api_reference/#pycrdt.Array.__add__","title":"<code>__add__(value)</code>","text":"<p>Extends the array with a list of items: <pre><code>Doc()[\"array\"] = array = Array([\"foo\"])\narray += [\"bar\", \"baz\"]\nassert array.to_py() == [\"foo\", \"bar\", \"baz\"]\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>list[Any]</code> <p>The items that will extend the array.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>The extended array.</p>"},{"location":"api_reference/#pycrdt.Array.__contains__","title":"<code>__contains__(item)</code>","text":"<p>Checks if the given item is in the array: <pre><code>Doc()[\"array\"] = array = Array([\"foo\", \"bar\"])\nassert \"baz\" not in array\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>The item to look for in the array.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the item was found.</p>"},{"location":"api_reference/#pycrdt.Array.__delitem__","title":"<code>__delitem__(key)</code>","text":"<p>Removes the item at the given index from the array: <pre><code>Doc()[\"array\"] = array = Array([\"foo\", \"bar\", \"baz\"])\ndel array[2]\nassert array.to_py() == [\"foo\", \"bar\"]\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>int | slice</code> <p>The index of the item to remove.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Array indices must be integers or slices.</p>"},{"location":"api_reference/#pycrdt.Array.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Gets the item at the given index: <pre><code>Doc()[\"array\"] = array = Array([\"foo\", \"bar\", \"baz\"])\nassert array[1] == \"bar\"\n</code></pre></p> <p>Returns:</p> Type Description <code>BaseType</code> <p>The item at the given index.</p>"},{"location":"api_reference/#pycrdt.Array.__init__","title":"<code>__init__(init=None, *, _doc=None, _integrated=None)</code>","text":"<p>Creates an array with an optional initial value: <pre><code>array0 = Array()\narray1 = Array([\"foo\", 3, array0])\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>init</code> <code>list | None</code> <p>The list from which to initialize the array.</p> <code>None</code>"},{"location":"api_reference/#pycrdt.Array.__iter__","title":"<code>__iter__()</code>","text":"<p><pre><code>Doc()[\"array\"] = array = Array([\"foo\", \"foo\"])\nfor value in array:\n    assert value == \"foo\"\n</code></pre> Returns:     An iterable over the items of the array.</p>"},{"location":"api_reference/#pycrdt.Array.__len__","title":"<code>__len__()</code>","text":"<pre><code>Doc()[\"array\"] = array = Array([2, 3, 0])\nassert len(array) == 3\n</code></pre> <p>Returns:</p> Type Description <code>int</code> <p>The length of the array.</p>"},{"location":"api_reference/#pycrdt.Array.__radd__","title":"<code>__radd__(value)</code>","text":"<p>Prepends a list of items to the array: <pre><code>Doc()[\"array\"] = array = Array([\"bar\", \"baz\"])\narray = [\"foo\"] + array\nassert array.to_py() == [\"foo\", \"bar\", \"baz\"]\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>list[Any]</code> <p>The list of items to prepend.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>The prepended array.</p>"},{"location":"api_reference/#pycrdt.Array.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Replaces the item at the given index with a new item: <pre><code>Doc()[\"array\"] = array = Array([\"foo\", \"bar\"])\narray[1] = \"baz\"\nassert array.to_py() == [\"foo\", \"baz\"]\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>int | slice</code> <p>The index of the item to replace.</p> required <code>value</code> <code>Any | list[Any]</code> <p>The new item to set.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Index must be of type integer.</p>"},{"location":"api_reference/#pycrdt.Array.__str__","title":"<code>__str__()</code>","text":"<pre><code>Doc()[\"array\"] = array = Array([2, 3, 0])\nassert str(array) == \"[2,3,0]\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the array.</p>"},{"location":"api_reference/#pycrdt.Array.append","title":"<code>append(value)</code>","text":"<p>Appends an item to the array.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The item to append to the array.</p> required"},{"location":"api_reference/#pycrdt.Array.clear","title":"<code>clear()</code>","text":"<p>Removes all items from the array.</p>"},{"location":"api_reference/#pycrdt.Array.extend","title":"<code>extend(value)</code>","text":"<p>Extends the array with a list of items.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>list[Any]</code> <p>The items that will extend the array.</p> required"},{"location":"api_reference/#pycrdt.Array.insert","title":"<code>insert(index, object)</code>","text":"<p>Inserts an item at a given index in the array.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index where to insert the item.</p> required <code>object</code> <code>Any</code> <p>The item to insert in the array.</p> required"},{"location":"api_reference/#pycrdt.Array.move","title":"<code>move(source_index, destination_index)</code>","text":"<p>Moves an item in the array from a source index to a destination index.</p> <p>Parameters:</p> Name Type Description Default <code>source_index</code> <code>int</code> <p>The index of the item to move.</p> required <code>destination_index</code> <code>int</code> <p>The index where the item will be inserted.</p> required"},{"location":"api_reference/#pycrdt.Array.observe","title":"<code>observe(callback)</code>","text":"<p>Subscribes a callback to be called with the array event.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[ArrayEvent], None]</code> <p>The callback to call with the ArrayEvent.</p> required"},{"location":"api_reference/#pycrdt.Array.observe_deep","title":"<code>observe_deep(callback)</code>","text":"<p>Subscribes a callback for all events emitted by this and nested collaborative types.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[list[BaseEvent]], None]</code> <p>The callback to call with the list of events.</p> required"},{"location":"api_reference/#pycrdt.Array.pop","title":"<code>pop(index=-1)</code>","text":"<p>Removes the item at the given index from the array, and returns it. If no index is passed, removes and returns the last item.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The optional index of the item to pop.</p> <code>-1</code> <p>Returns:</p> Type Description <code>Any</code> <p>The item at the given index, or the last item.</p>"},{"location":"api_reference/#pycrdt.Array.to_py","title":"<code>to_py()</code>","text":"<p>Recursively converts the array's items to Python objects, and returns them in a list. If the array was not yet inserted in a document, returns <code>None</code> if the array was not initialized.</p> <p>Returns:</p> Type Description <code>list | None</code> <p>The array recursively converted to Python objects, or <code>None</code>.</p>"},{"location":"api_reference/#pycrdt.Array.unobserve","title":"<code>unobserve(subscription)</code>","text":"<p>Unsubscribes to changes using the given subscription.</p> <p>Parameters:</p> Name Type Description Default <code>subscription</code> <code>Subscription</code> <p>The subscription to unregister.</p> required"},{"location":"api_reference/#pycrdt.ArrayEvent","title":"<code>ArrayEvent</code>","text":"<p>               Bases: <code>BaseEvent</code></p> <p>An array change event.</p> <p>Attributes:</p> Name Type Description <code>target</code> <code>Array</code> <p>The changed array.</p> <code>delta</code> <code>list[dict[str, Any]]</code> <p>A list of items describing the changes.</p> <code>path</code> <code>list[int | str]</code> <p>A list with the indices pointing to the array that was changed.</p>"},{"location":"api_reference/#pycrdt.Decoder","title":"<code>Decoder</code>","text":"<p>A decoder capable of reading messages from a byte stream.</p>"},{"location":"api_reference/#pycrdt.Decoder.__init__","title":"<code>__init__(stream)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>stream</code> <code>bytes</code> <p>The byte stream from which to read messages.</p> required"},{"location":"api_reference/#pycrdt.Decoder.read_message","title":"<code>read_message()</code>","text":"<p>Reads a message from the byte stream, ready to read the next message if any.</p> <p>Returns:</p> Type Description <code>bytes | None</code> <p>The current message, if any.</p>"},{"location":"api_reference/#pycrdt.Decoder.read_messages","title":"<code>read_messages()</code>","text":"<p>A generator that reads messages from the byte stream.</p> <p>Returns:</p> Type Description <code>Iterator[bytes]</code> <p>A generator that yields messages.</p>"},{"location":"api_reference/#pycrdt.Decoder.read_var_string","title":"<code>read_var_string()</code>","text":"<p>Reads a message as an UTF-8 string from the byte stream, ready to read the next message if any.</p> <p>Returns:</p> Type Description <code>str</code> <p>The current message as a string.</p>"},{"location":"api_reference/#pycrdt.Decoder.read_var_uint","title":"<code>read_var_uint()</code>","text":"<p>Decodes the current message length.</p> <p>Returns:</p> Type Description <code>int</code> <p>The decoded length of the message.</p>"},{"location":"api_reference/#pycrdt.Doc","title":"<code>Doc</code>","text":"<p>               Bases: <code>BaseDoc</code></p> <p>A shared document.</p> <p>All shared types live within the scope of their corresponding documents. All updates are generated on a per-document basis. All operations on shared types happen in a transaction, whose lifetime is also bound to a document.</p>"},{"location":"api_reference/#pycrdt.Doc.client_id","title":"<code>client_id: int</code>  <code>property</code>","text":"<p>The document client ID.</p>"},{"location":"api_reference/#pycrdt.Doc.guid","title":"<code>guid: int</code>  <code>property</code>","text":"<p>The GUID of the document.</p>"},{"location":"api_reference/#pycrdt.Doc.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Gets the document root type corresponding to the given key: <pre><code>text = doc[\"text\"]\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the root type to get.</p> required <p>Returns:</p> Type Description <code>BaseType</code> <p>The document root type.</p>"},{"location":"api_reference/#pycrdt.Doc.__init__","title":"<code>__init__(init={}, *, client_id=None, doc=None, Model=None, allow_multithreading=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>init</code> <code>dict[str, BaseType]</code> <p>The initial root types of the document.</p> <code>{}</code> <code>client_id</code> <code>int | None</code> <p>An optional client ID for the document.</p> <code>None</code> <code>allow_multithreading</code> <code>bool</code> <p>Whether to allow the document to be used in different threads.</p> <code>False</code>"},{"location":"api_reference/#pycrdt.Doc.__iter__","title":"<code>__iter__()</code>","text":"<p>Returns:</p> Type Description <code>Iterable[str]</code> <p>An iterable over the keys of the document root types.</p>"},{"location":"api_reference/#pycrdt.Doc.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Sets a document root type: <pre><code>doc[\"text\"] = Text(\"Hello\")\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the root type.</p> required <code>value</code> <code>BaseType</code> <p>The root type.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Key must be of type string.</p>"},{"location":"api_reference/#pycrdt.Doc.apply_update","title":"<code>apply_update(update)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>update</code> <code>bytes</code> <p>The update to apply to the document.</p> required"},{"location":"api_reference/#pycrdt.Doc.get","title":"<code>get(key, *, type)</code>","text":"<p>Gets the document root type corresponding to the given key. If it already exists, it will be cast to the given type (if different), otherwise a new root type is created. <pre><code>doc.get(\"text\", type=Text)\n</code></pre></p> <p>Returns:</p> Type Description <code>T_BaseType</code> <p>The root type corresponding to the given key, cast to the given type.</p>"},{"location":"api_reference/#pycrdt.Doc.get_state","title":"<code>get_state()</code>","text":"<p>Returns:</p> Type Description <code>bytes</code> <p>The current document state.</p>"},{"location":"api_reference/#pycrdt.Doc.get_update","title":"<code>get_update(state=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>state</code> <code>bytes | None</code> <p>The optional document state from which to get the update.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The update from the given document state (if any), or from the document creation.</p>"},{"location":"api_reference/#pycrdt.Doc.items","title":"<code>items()</code>","text":"<p>Returns:</p> Type Description <code>Iterable[tuple[str, BaseType]]</code> <p>An iterable over the key-value pairs of document root types.</p>"},{"location":"api_reference/#pycrdt.Doc.keys","title":"<code>keys()</code>","text":"<p>Returns:</p> Type Description <code>Iterable[str]</code> <p>An iterable over the names of the document root types.</p>"},{"location":"api_reference/#pycrdt.Doc.new_transaction","title":"<code>new_transaction(origin=None, timeout=None)</code>","text":"<p>Creates a new transaction. Unlike transaction(), this method will not reuse an ongoing transaction. If there is already an ongoing transaction, this method will wait (with an optional timeout) until the current transaction has finished. There are two ways to do so:</p> <ul> <li> <p>Use an async context manager: <pre><code>async with doc.new_transaction():\n    ...\n</code></pre> In this case you most likely access the document in the same thread, which means that the Doc can be created with <code>allow_multithreading=False</code>.</p> </li> <li> <p>Use a (sync) context manager: <pre><code>with doc.new_transaction():\n    ...\n</code></pre> In this case you want to use multithreading, as the ongoing transaction must run in another thread (otherwise this will deadlock), which means that the Doc must have been created with <code>allow_multithreading=True</code>.</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>Any</code> <p>An optional origin to set on this transaction.</p> <code>None</code> <code>timeout</code> <code>float | None</code> <p>An optional timeout (in seconds) to acquire a new transaction.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Already in a transaction.</p> <code>TimeoutError</code> <p>Could not acquire transaction.</p> <p>Returns:</p> Type Description <code>NewTransaction</code> <p>A new transaction.</p>"},{"location":"api_reference/#pycrdt.Doc.observe","title":"<code>observe(callback)</code>","text":"<p>Subscribes a callback to be called with the document change event.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[TransactionEvent], None]</code> <p>The callback to call with the TransactionEvent.</p> required <p>Returns:</p> Type Description <code>Subscription</code> <p>The subscription that can be used to unobserve().</p>"},{"location":"api_reference/#pycrdt.Doc.observe_subdocs","title":"<code>observe_subdocs(callback)</code>","text":"<p>Subscribes a callback to be called with the document subdoc change event.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[SubdocsEvent], None]</code> <p>The callback to call with the SubdocsEvent.</p> required <p>Returns:</p> Type Description <code>Subscription</code> <p>The subscription that can be used to unobserve().</p>"},{"location":"api_reference/#pycrdt.Doc.transaction","title":"<code>transaction(origin=None)</code>","text":"<p>Creates a new transaction or gets the current one, if any. If an origin is passed and there is already an ongoing transaction, the passed origin must be the same as the origin of the current transaction.</p> <p>This method must be used with a context manager:</p> <pre><code>with doc.transaction():\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>Any</code> <p>An optional origin to set on this transaction.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Nested transactions must have same origin as root transaction.</p> <p>Returns:</p> Type Description <code>Transaction</code> <p>A new transaction or the current one.</p>"},{"location":"api_reference/#pycrdt.Doc.unobserve","title":"<code>unobserve(subscription)</code>","text":"<p>Unsubscribes to changes using the given subscription.</p> <p>Parameters:</p> Name Type Description Default <code>subscription</code> <code>Subscription</code> <p>The subscription to unregister.</p> required"},{"location":"api_reference/#pycrdt.Doc.values","title":"<code>values()</code>","text":"<p>Returns:</p> Type Description <code>Iterable[BaseType]</code> <p>An iterable over the document root types.</p>"},{"location":"api_reference/#pycrdt.Map","title":"<code>Map</code>","text":"<p>               Bases: <code>BaseType</code></p> <p>A collection used to store key-value entries in an unordered manner, similar to a Python <code>dict</code>.</p>"},{"location":"api_reference/#pycrdt.Map.doc","title":"<code>doc: Doc</code>  <code>property</code>","text":"<p>The document this shared type belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Not integrated in a document yet.</p>"},{"location":"api_reference/#pycrdt.Map.__contains__","title":"<code>__contains__(item)</code>","text":"<p>Checks if the given key is in the map: <pre><code>Doc()[\"map0\"] = map0 = Map({\"foo\": 0, \"bar\": 0})\nassert \"baz\" not in map0:\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>The key to look for in the map.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the key was found.</p>"},{"location":"api_reference/#pycrdt.Map.__delitem__","title":"<code>__delitem__(key)</code>","text":"<p>Removes the item at the given key from the map: <pre><code>Doc()[\"map0\"] = map0 = Map({\"foo\": 0, \"bar\": 1})\ndel map0[\"foo\"]\nassert map0.to_py() == {\"bar\": 1}\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the item to remove.</p> required"},{"location":"api_reference/#pycrdt.Map.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Gets the value at the given key: <pre><code>Doc()[\"map0\"] = map0 = Map({\"foo\": 0, \"bar\": 1})\nassert map0[\"foo\"] == 0\n</code></pre></p> <p>Returns:</p> Type Description <code>Any</code> <p>The value at the given key.</p>"},{"location":"api_reference/#pycrdt.Map.__init__","title":"<code>__init__(init=None, *, _doc=None, _integrated=None)</code>","text":"<p>Creates a map with an optional initial value: <pre><code>map0 = Map()\nmap1 = Map({\"foo\": 0, \"bar\": 3, \"baz\": map0})\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>init</code> <code>dict | None</code> <p>The list from which to initialize the array.</p> <code>None</code>"},{"location":"api_reference/#pycrdt.Map.__iter__","title":"<code>__iter__()</code>","text":"<p><pre><code>Doc()[\"map0\"] = map0 = Map({\"foo\": 0, \"bar\": 0})\nfor key in m0:\n    assert map[key] == 0\n</code></pre> Returns:     An iterable over the keys of the map.</p>"},{"location":"api_reference/#pycrdt.Map.__len__","title":"<code>__len__()</code>","text":"<p><pre><code>Doc()[\"map0\"] = map0 = Map({\"foo\": 0, \"bar\": 1})\nassert len(map0) == 2\n</code></pre> Returns:     The length of the map.</p>"},{"location":"api_reference/#pycrdt.Map.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Sets a value at the given key: <pre><code>Doc()[\"map0\"] = map0 = Map({\"foo\": 0, \"bar\": 1})\nmap0[\"foo\"] = 2\nassert map0[\"foo\"] == 2\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to set.</p> required <code>value</code> <code>Any</code> <p>The value to set.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Key must be of type string.</p>"},{"location":"api_reference/#pycrdt.Map.__str__","title":"<code>__str__()</code>","text":"<pre><code>Doc()[\"map0\"] = map0 = Map({\"foo\": 0, \"bar\": 1})\nassert str(map0) == '{\"foo\":0,\"bar\":1}'\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the map.</p>"},{"location":"api_reference/#pycrdt.Map.clear","title":"<code>clear()</code>","text":"<p>Removes all entries from the map.</p>"},{"location":"api_reference/#pycrdt.Map.get","title":"<code>get(key, default_value=None)</code>","text":"<p>Returns the value corresponding to the given key if it exists, otherwise returns the <code>default_value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the value to get.</p> required <code>default_value</code> <code>Any | None</code> <p>The optional default value to return if the key is not found.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any | None</code> <p>The value at the given key, or the default value.</p>"},{"location":"api_reference/#pycrdt.Map.items","title":"<code>items()</code>","text":"<p>Returns:</p> Type Description <code>Iterable[tuple[str, Any]]</code> <p>An iterable over the key-value pairs of the map.</p>"},{"location":"api_reference/#pycrdt.Map.keys","title":"<code>keys()</code>","text":"<p>Returns:</p> Type Description <code>Iterable[str]</code> <p>An iterable over the keys of the map.</p>"},{"location":"api_reference/#pycrdt.Map.observe","title":"<code>observe(callback)</code>","text":"<p>Subscribes a callback to be called with the map event.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[MapEvent], None]</code> <p>The callback to call with the MapEvent.</p> required"},{"location":"api_reference/#pycrdt.Map.observe_deep","title":"<code>observe_deep(callback)</code>","text":"<p>Subscribes a callback for all events emitted by this and nested collaborative types.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[list[BaseEvent]], None]</code> <p>The callback to call with the list of events.</p> required"},{"location":"api_reference/#pycrdt.Map.pop","title":"<code>pop(*args)</code>","text":"<p>Removes the entry at the given key from the map, and returns the corresponding value.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>The key of the value to pop, and an optional default value.</p> <code>()</code> <p>Returns:</p> Type Description <code>Any</code> <p>The value at the given key, or the default value if passed.</p>"},{"location":"api_reference/#pycrdt.Map.to_py","title":"<code>to_py()</code>","text":"<p>Recursively converts the map's items to Python objects, and returns them in a <code>dict</code>. If the map was not yet inserted in a document, returns <code>None</code> if the map was not initialized.</p> <p>Returns:</p> Type Description <code>dict | None</code> <p>The map recursively converted to Python objects, or <code>None</code>.</p>"},{"location":"api_reference/#pycrdt.Map.unobserve","title":"<code>unobserve(subscription)</code>","text":"<p>Unsubscribes to changes using the given subscription.</p> <p>Parameters:</p> Name Type Description Default <code>subscription</code> <code>Subscription</code> <p>The subscription to unregister.</p> required"},{"location":"api_reference/#pycrdt.Map.update","title":"<code>update(value)</code>","text":"<p>Sets entries in the map from all entries in the passed <code>dict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>dict[str, Any]</code> <p>The <code>dict</code> from which to get the entries to update.</p> required"},{"location":"api_reference/#pycrdt.Map.values","title":"<code>values()</code>","text":"<p>Returns:</p> Type Description <code>Iterable[Any]</code> <p>An iterable over the values of the map.</p>"},{"location":"api_reference/#pycrdt.MapEvent","title":"<code>MapEvent</code>","text":"<p>               Bases: <code>BaseEvent</code></p> <p>A map change event.</p> <p>Attributes:</p> Name Type Description <code>target</code> <code>Map</code> <p>The changed map.</p> <code>delta</code> <code>list[dict[str, Any]]</code> <p>A list of items describing the changes.</p> <code>path</code> <code>list[int | str]</code> <p>A list with the indices pointing to the map that was changed.</p>"},{"location":"api_reference/#pycrdt.NewTransaction","title":"<code>NewTransaction</code>","text":"<p>               Bases: <code>Transaction</code></p> <p>A read-write transaction that can be used to mutate a document. It can be used with a context manager or an async context manager (see Doc.new_transaction()): <pre><code>with doc.new_transaction():\n    ...\n\nasync with doc.new_transaction():\n    ...\n</code></pre></p>"},{"location":"api_reference/#pycrdt.NewTransaction.origin","title":"<code>origin: Any</code>  <code>property</code>","text":"<p>The origin of the transaction.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>No current transaction.</p>"},{"location":"api_reference/#pycrdt.ReadTransaction","title":"<code>ReadTransaction</code>","text":"<p>               Bases: <code>Transaction</code></p> <p>A read-only transaction that cannot be used to mutate a document.</p>"},{"location":"api_reference/#pycrdt.ReadTransaction.origin","title":"<code>origin: Any</code>  <code>property</code>","text":"<p>The origin of the transaction.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>No current transaction.</p>"},{"location":"api_reference/#pycrdt.StackItem","title":"<code>StackItem</code>","text":"<p>A unit of work for the UndoManager, consisting of compressed information about all updates and deletions tracked by it.</p>"},{"location":"api_reference/#pycrdt.Subscription","title":"<code>Subscription</code>","text":"<p>Observer subscription.</p>"},{"location":"api_reference/#pycrdt.Subscription.drop","title":"<code>drop()</code>","text":"<p>Drops the subscription, effectively unobserving.</p>"},{"location":"api_reference/#pycrdt.SubdocsEvent","title":"<code>SubdocsEvent</code>","text":"<p>Event generated by the observe_subdocs method, emitted during the transaction commit phase.</p>"},{"location":"api_reference/#pycrdt.Text","title":"<code>Text</code>","text":"<p>               Bases: <code>BaseType</code></p> <p>A shared data type used for collaborative text editing, similar to a Python <code>str</code>.</p>"},{"location":"api_reference/#pycrdt.Text.doc","title":"<code>doc: Doc</code>  <code>property</code>","text":"<p>The document this shared type belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Not integrated in a document yet.</p>"},{"location":"api_reference/#pycrdt.Text.__contains__","title":"<code>__contains__(item)</code>","text":"<p>Checks if the given string is in the text: <pre><code>Doc()[\"text\"] = text = Text(\"Hello, World!\")\nassert \"World\" in text\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>The string to look for in the text.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the string was found.</p>"},{"location":"api_reference/#pycrdt.Text.__delitem__","title":"<code>__delitem__(key)</code>","text":"<p>Removes the characters at the given index or slice: <pre><code>Doc()[\"text\"] = text = Text(\"Hello, World!\")\ndel text[5]\nassert str(text) == \"Hello World!\"\ndel text[5:]\nassert str(text) == \"Hello\"\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>int | slice</code> <p>The index or the slice of the characters to remove.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Step not supported.</p> <code>RuntimeError</code> <p>Negative start not supported.</p> <code>RuntimeError</code> <p>Negative stop not supported.</p>"},{"location":"api_reference/#pycrdt.Text.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Gets the characters at the given index or slice: <pre><code>Doc()[\"text\"] = text = Text(\"Hello, World!\")\nassert text[:5] == \"Hello\"\n</code></pre></p> <p>Returns:</p> Type Description <code>str</code> <p>The characters at the given index or slice.</p>"},{"location":"api_reference/#pycrdt.Text.__iadd__","title":"<code>__iadd__(value)</code>","text":"<p>Concatenates a string to the text: <pre><code>Doc()[\"text\"] = text = Text(\"Hello\")\ntext += \", World!\"\nassert str(text) == \"Hello, World!\"\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The string to concatenate.</p> required <p>Returns:</p> Type Description <code>Text</code> <p>The concatenated text.</p>"},{"location":"api_reference/#pycrdt.Text.__init__","title":"<code>__init__(init=None, *, _doc=None, _integrated=None)</code>","text":"<p>Creates a text with an optional initial value: <pre><code>text = Text(\"Hello, World!\")\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>init</code> <code>str | None</code> <p>The string from which to initialize the text.</p> <code>None</code>"},{"location":"api_reference/#pycrdt.Text.__iter__","title":"<code>__iter__()</code>","text":"<pre><code>Doc()[\"text\"] = text = Text(\"***\")\nfor character in text:\n    assert character == \"*\"\n</code></pre> <p>Returns:</p> Type Description <code>TextIterator</code> <p>An iterable over the characters of the text.</p>"},{"location":"api_reference/#pycrdt.Text.__len__","title":"<code>__len__()</code>","text":"<pre><code>Doc()[\"text\"] = text = Text(\"Hello\")\nassert len(text) == 5\n</code></pre> <p>Returns:</p> Type Description <code>int</code> <p>The length of the text.</p>"},{"location":"api_reference/#pycrdt.Text.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Replaces the characters at the given index or slice with new characters: <pre><code>Doc()[\"text\"] = text = Text(\"Hello, World!\")\ntext[7:12] = \"Brian\"\nassert text == \"Hello, Brian!\"\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>int | slice</code> <p>The index or slice of the characters to replace.</p> required <code>value</code> <code>str</code> <p>The new characters to set.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Step not supported.</p> <code>RuntimeError</code> <p>Negative start not supported.</p> <code>RuntimeError</code> <p>Negative stop not supported.</p> <code>RuntimeError</code> <p>Single item assigned value must have a length of 1.</p>"},{"location":"api_reference/#pycrdt.Text.__str__","title":"<code>__str__()</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>The text as a Python <code>str</code>.</p>"},{"location":"api_reference/#pycrdt.Text.clear","title":"<code>clear()</code>","text":"<p>Remove the entire range of characters.</p>"},{"location":"api_reference/#pycrdt.Text.insert","title":"<code>insert(index, value)</code>","text":"<p>Inserts a string at a given index in the text. Doc()[\"text\"] = text = Text(\"Hello World!\") text.insert(5, \",\") assert text == \"Hello, World!\"</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index where to insert the string.</p> required <code>value</code> <code>str</code> <p>The string to insert in the text.</p> required"},{"location":"api_reference/#pycrdt.Text.observe","title":"<code>observe(callback)</code>","text":"<p>Subscribes a callback to be called with the text event.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[TextEvent], None]</code> <p>The callback to call with the TextEvent.</p> required"},{"location":"api_reference/#pycrdt.Text.observe_deep","title":"<code>observe_deep(callback)</code>","text":"<p>Subscribes a callback for all events emitted by this and nested collaborative types.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[list[BaseEvent]], None]</code> <p>The callback to call with the list of events.</p> required"},{"location":"api_reference/#pycrdt.Text.to_py","title":"<code>to_py()</code>","text":"<p>Returns:</p> Type Description <code>str | None</code> <p>The text as a Python <code>str</code>.</p>"},{"location":"api_reference/#pycrdt.Text.unobserve","title":"<code>unobserve(subscription)</code>","text":"<p>Unsubscribes to changes using the given subscription.</p> <p>Parameters:</p> Name Type Description Default <code>subscription</code> <code>Subscription</code> <p>The subscription to unregister.</p> required"},{"location":"api_reference/#pycrdt.TextEvent","title":"<code>TextEvent</code>","text":"<p>               Bases: <code>BaseEvent</code></p> <p>A text change event.</p> <p>Attributes:</p> Name Type Description <code>target</code> <code>Text</code> <p>The changed text.</p> <code>delta</code> <code>list[dict[str, Any]]</code> <p>A list of items describing the changes.</p> <code>path</code> <code>list[int | str]</code> <p>A list with the indices pointing to the text that was changed.</p>"},{"location":"api_reference/#pycrdt.Transaction","title":"<code>Transaction</code>","text":"<p>A read-write transaction that can be used to mutate a document. It must be used with a context manager (see Doc.transaction()): <pre><code>with doc.transaction():\n    ...\n</code></pre></p>"},{"location":"api_reference/#pycrdt.Transaction.origin","title":"<code>origin: Any</code>  <code>property</code>","text":"<p>The origin of the transaction.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>No current transaction.</p>"},{"location":"api_reference/#pycrdt.TransactionEvent","title":"<code>TransactionEvent</code>","text":"<p>Event generated by the observe method, emitted during the transaction commit phase.</p>"},{"location":"api_reference/#pycrdt.TransactionEvent.update","title":"<code>update: bytes</code>  <code>property</code>","text":"<p>The emitted binary update.</p>"},{"location":"api_reference/#pycrdt.UndoManager","title":"<code>UndoManager</code>","text":"<p>The undo manager allows to perform undo/redo operations on shared types. It can be initialized either with a Doc or with scopes. Scopes are a list of shared types integrated in a document. If initialized with a <code>Doc</code>, scopes can later be expanded. Changes can be undone/redone by batches using time intervals. It is possible to include/exclude changes by transaction origin in undo/redo operations.</p>"},{"location":"api_reference/#pycrdt.UndoManager.redo_stack","title":"<code>redo_stack: list[StackItem]</code>  <code>property</code>","text":"<p>The list of redoable actions.</p>"},{"location":"api_reference/#pycrdt.UndoManager.undo_stack","title":"<code>undo_stack: list[StackItem]</code>  <code>property</code>","text":"<p>The list of undoable actions.</p>"},{"location":"api_reference/#pycrdt.UndoManager.__init__","title":"<code>__init__(*, doc=None, scopes=[], capture_timeout_millis=500)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>doc</code> <code>Doc | None</code> <p>The document the undo manager will work with.</p> <code>None</code> <code>scopes</code> <code>list[BaseType]</code> <p>A list of shared types the undo manager will work with.</p> <code>[]</code> <code>capture_timeout_millis</code> <code>int</code> <p>A time interval for grouping changes that will be undone/redone.</p> <code>500</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>UndoManager must be created with doc or scopes.</p>"},{"location":"api_reference/#pycrdt.UndoManager.can_redo","title":"<code>can_redo()</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>True if there are changes to redo.</p>"},{"location":"api_reference/#pycrdt.UndoManager.can_undo","title":"<code>can_undo()</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>True if there are changes to undo.</p>"},{"location":"api_reference/#pycrdt.UndoManager.clear","title":"<code>clear()</code>","text":"<p>Clears all StackItems stored in this undo manager, effectively resetting its state.</p>"},{"location":"api_reference/#pycrdt.UndoManager.exclude_origin","title":"<code>exclude_origin(origin)</code>","text":"<p>Removes a transaction origin from the list of origins tracked by this undo manager.</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>Any</code> <p>The origin to exclude.</p> required"},{"location":"api_reference/#pycrdt.UndoManager.expand_scope","title":"<code>expand_scope(scope)</code>","text":"<p>Expands the scope of shared types for this undo manager.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>BaseType</code> <p>The shared type to include.</p> required"},{"location":"api_reference/#pycrdt.UndoManager.include_origin","title":"<code>include_origin(origin)</code>","text":"<p>Extends the list of transactions origin tracked by this undo manager.</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>Any</code> <p>The origin to include.</p> required"},{"location":"api_reference/#pycrdt.UndoManager.redo","title":"<code>redo()</code>","text":"<p>Perform a redo operation.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if some changes were redone.</p>"},{"location":"api_reference/#pycrdt.UndoManager.undo","title":"<code>undo()</code>","text":"<p>Perform an undo operation.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if some changes were undone.</p>"},{"location":"api_reference/#pycrdt.YMessageType","title":"<code>YMessageType</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>A generic Y message type.</p> <p>Attributes:</p> Name Type Description <code>SYNC</code> <code>int</code> <p>A message type used for synchronizing documents.</p> <code>AWARENESS</code> <code>int</code> <p>A message type used for the awareness protocol.</p>"},{"location":"api_reference/#pycrdt.YSyncMessageType","title":"<code>YSyncMessageType</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>A message type used for synchronizing documents.</p> <p>Attributes:</p> Name Type Description <code>SYNC_STEP1</code> <code>int</code> <p>A synchronization message type used to send a document state.</p> <code>SYNC_STEP2</code> <code>int</code> <p>A synchronization message type used to reply to a SYNC_STEP1, consisting of all missing updates and all deletions.</p> <code>SYNC_UPDATE</code> <code>int</code> <p>A synchronization message type used to send document updates.</p>"},{"location":"api_reference/#pycrdt.create_sync_message","title":"<code>create_sync_message(ydoc)</code>","text":"<p>Creates a SYNC_STEP1 message that contains the state of a Doc.</p> <p>Parameters:</p> Name Type Description Default <code>ydoc</code> <code>Doc</code> <p>The Doc for which to create the message.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>A SYNC_STEP1 message.</p>"},{"location":"api_reference/#pycrdt.create_update_message","title":"<code>create_update_message(data)</code>","text":"<p>Creates a SYNC_UPDATE message that contains a document update.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The document update.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>A SYNC_UPDATE message.</p>"},{"location":"api_reference/#pycrdt.handle_sync_message","title":"<code>handle_sync_message(message, ydoc)</code>","text":"<p>Processes a synchronization message on a document.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes</code> <p>A synchronization message.</p> required <code>ydoc</code> <code>Doc</code> <p>The Doc that this message targets.</p> required <p>Returns:</p> Type Description <code>bytes | None</code> <p>The SYNC_STEP2 reply message, if the message</p> <code>bytes | None</code> <p>was a SYNC_STEP1.</p>"},{"location":"api_reference/#pycrdt.get_state","title":"<code>get_state(update)</code>","text":"<p>Returns a state from an update.</p> <p>Parameters:</p> Name Type Description Default <code>update</code> <code>bytes</code> <p>The update from which to get the state.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The state corresponding to the update.</p>"},{"location":"api_reference/#pycrdt.get_update","title":"<code>get_update(update, state)</code>","text":"<p>Returns an update consisting of all changes from a given update which have not been seen in the given state.</p> <p>Parameters:</p> Name Type Description Default <code>update</code> <code>bytes</code> <p>The update from which to get all missing changes in the given state.</p> required <code>state</code> <code>bytes</code> <p>The state from which to get missing changes that are in the given update.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The changes from the given update not present in the given state.</p>"},{"location":"api_reference/#pycrdt.merge_updates","title":"<code>merge_updates(*updates)</code>","text":"<p>Returns an update consisting of a combination of all given updates.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>bytes</code> <p>The updates to merge.</p> <code>()</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The merged updates.</p>"},{"location":"api_reference/#pycrdt.read_message","title":"<code>read_message(stream)</code>","text":"<p>Reads a message from a byte stream.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>bytes</code> <p>The byte stream from which to read the message.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The message read from the byte stream.</p>"},{"location":"api_reference/#pycrdt.write_var_uint","title":"<code>write_var_uint(num)</code>","text":"<p>Encodes a payload length.</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>int</code> <p>The payload length to encode.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The encoded payload length.</p>"},{"location":"install/","title":"Install","text":"<p>Pycrdt can be installed through PyPI or conda-forge.</p>"},{"location":"install/#with-pip","title":"With <code>pip</code>","text":"<pre><code>pip install pycrdt\n</code></pre>"},{"location":"install/#with-micromamba","title":"With <code>micromamba</code>","text":"<p>We recommend using <code>micromamba</code> to manage <code>conda-forge</code> environments (see <code>micromamba</code>'s installation instructions). First create an environment, here called <code>my_env</code>, and activate it: <pre><code>micromamba create -n my_env\nmicromamba activate my_env\n</code></pre> Then install <code>pycrdt</code>.</p> <pre><code>micromamba install -c conda-forge pycrdt\n</code></pre>"},{"location":"install/#development-install","title":"Development install","text":"<p>You first need to clone the repository: <pre><code>git clone https://github.com/jupyter-server/pycrdt.git\ncd pycrdt\n</code></pre> We recommend working in a conda environment. In order to build <code>pycrdt</code>, you will need <code>pip</code> and the Rust compiler: <pre><code>micromamba create -n pycrdt-dev\nmicromamba activate pycrdt-dev\nmicromamba install -c conda-forge pip rust\n</code></pre> Then install <code>pycrdt</code> in editable mode: <pre><code>pip install -e .\n</code></pre> This will build the Rust extension using maturin. If you make changes to the Python code only, you don't need to recompile anything, changes will be reflected the next time you run the Python interpreter. If you make changes to the Rust code, you need to recompile it but you don't need to reinstall <code>pycrdt</code>, you can just re-build the Rust extension with: <pre><code># install maturin only once:\npip install maturin\n# build the Rust extension each time the Rust code changes:\nmaturin develop\n</code></pre></p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#quickstart","title":"Quickstart","text":"<p>Pycrdt offers the following shared data types:</p> <ul> <li><code>Text</code>: a type similar to a <code>str</code>.</li> <li><code>Array</code>: a type similar to a <code>list</code>.</li> <li><code>Map</code>: a type similar to a <code>dict</code>.</li> </ul> <p>You can initialize them with their Python built-in counterparts:</p> <pre><code>from pycrdt import Text, Array, Map\n\ntext0 = Text(\"Hello\")\narray0 = Array([0, \"foo\"])\nmap0 = Map({\"key0\": \"value0\"})\n</code></pre> <p>But they are pretty useless on their own. They are just placeholders waiting to be inserted in a shared document. Only then do they really become useful:</p> <pre><code>from pycrdt import Doc\n\ndoc = Doc()\ndoc[\"text0\"] = text0\ndoc[\"array0\"] = array0\ndoc[\"map0\"] = map0\n</code></pre> <p>Now you can operate on them as you would expect, for instance:</p> <pre><code>text0 += \", World!\"\narray0.append(\"bar\")\nmap0[\"key1\"] = \"value1\"\n</code></pre> <p>Note that an <code>Array</code> and a <code>Map</code> can hold other shared data types:</p> <pre><code>map1 = Map({\"baz\": 1})\narray1 = Array([5, 6, 7])\n\narray0.append(map1)\nmap0[\"key2\"] = array1\n</code></pre> <p>Every change to <code>doc</code> (a modified/added/deleted value) will generate an update in the form of a binary encoded data. You can listen to these updates and send them on the wire, so that they can be applied to a remote document.</p> <p>You can also listen to changes on the individual shared data types (<code>text0</code>, <code>array1</code>, etc.) by registering callbacks, that will be called with the change event(s), so that your application can react to data changes.</p> <p>We say that <code>text0</code>, <code>array0</code> and <code>map0</code> are root types of <code>doc</code>. When they got inserted into <code>doc</code>, we gave them a name. For instance, <code>text0</code> was inserted under <code>\"text0\"</code>. This is how a remote document will retrieve the root types of the document, after applying the received updates:</p> <pre><code>update = doc.get_update()\n\n# the (binary) update could travel on the wire to a remote machine:\n\nremote_doc = Doc()\nremote_doc.apply_update(update)\n\nremote_doc[\"text0\"] = text0 = Text()\nremote_doc[\"array0\"] = array0 = Array()\nremote_doc[\"map0\"] = map0 = Map()\n</code></pre> <p>You could say that there is nothing fancy here, it's just about encoding data changes so that they can be applied on another object. But this is where the magic of CRDTs comes into play. Their algorithm ensures that if some changes are done concurrently on different objects representing the same data (for instance on different machines), applying the changes will lead to the same data on all objects. Without such algorithms, this property doesn't hold due to the fact that changes depend on the order in which they are applied, and that they take time to travel on the wire.</p> <p>The most common example is inserting a different character on a text editor on two machines. Say we start with a blank page on both editors, and the user on machine A inserts \"a\" at the same time the user on machine B inserts \"b\". After receiving the other user's update, if no special care is taken, machine A will show \"ba\" and machine B will show \"ab\". In other words, their document states will diverge, and thus users won't collaborate on the same document anymore. CRDTs ensure that documents don't diverge, their shared documents will eventually have the same state. It will arbitrary be \"ab\" or \"ba\", but it will be the same on both machines.</p>"},{"location":"usage/#transactions","title":"Transactions","text":"<p>Every change to a shared data happens in a document transaction, and there can only be one transaction at a time. Pycrdt offers two methods for creating transactions:</p> <ul> <li><code>doc.transaction()</code>: used with a context manager, this will create a new transaction if there is no current one, or use the current transaction. This method will never block, and should be used most of the time.</li> <li><code>doc.new_transaction()</code>: used with a context manager or an async context manager, this will always try to create a new transaction. This method can block, waiting for a transaction to be released.</li> </ul>"},{"location":"usage/#non-blocking-transactions","title":"Non-blocking transactions","text":"<p>When no current transaction exists, an implicit transaction is created. Grouping multiple changes in a single transaction makes them atomic: they will appear as done simultaneously rather than sequentially.</p> <pre><code>with doc.transaction():\n    text0 += \", World!\"\n    array0.append(\"bar\")\n    map0[\"key1\"] = \"value1\"\n</code></pre> <p>Transactions can be nested: when a transaction is created inside another one, changes will be made in the outer transaction. In the following example, all changes are made in transaction <code>t0</code>.</p> <pre><code>with doc.transaction() as t0:\n    text0 += \", World!\"\n    with doc.transaction() as t1:\n        array0.append(\"bar\")\n        with doc.transaction() as t2:\n            map0[\"key1\"] = \"value1\"\n</code></pre>"},{"location":"usage/#blocking-transactions","title":"Blocking transactions","text":""},{"location":"usage/#multithreading","title":"Multithreading","text":"<p>When used with a (non-async) context manager, the <code>new_transaction()</code> method will block the current thread waiting to acquire a transaction, with an optional timeout:</p> <pre><code>from threading import Thread\nfrom pycrdt import Doc\n\ndoc = Doc(allow_multithreading=True)\n\ndef create_new_transaction():\n    with doc.new_transaction(timeout=3):\n        ...\n\nt0 = Thread(target=create_new_transaction)\nt1 = Thread(target=create_new_transaction)\nt0.start()\nt1.start()\nt0.join()\nt1.join()\n</code></pre>"},{"location":"usage/#asynchronous-programming","title":"Asynchronous programming","text":"<p>When used with an async context manager, the <code>new_transaction()</code> method will yield to the event loop until a transaction is acquired:</p> <pre><code>from anyio import create_task_group, run\nfrom pycrdt import Doc\n\ndoc = Doc()\n\nasync def create_new_transaction():\n    async with doc.new_transaction(timeout=3):\n        ...\n\nasync def main():\n    async with create_task_group() as tg:\n        tg.start_soon(create_new_transaction)\n        tg.start_soon(create_new_transaction)\n\nrun(main)\n</code></pre>"},{"location":"usage/#events","title":"Events","text":""},{"location":"usage/#shared-data-events","title":"Shared data events","text":"<p>Changes to shared data can be observed in order to react on them. For instance, if a character is inserted in a <code>Text</code> data, a text editor should insert the character in the text shown to the user. This is done by registering callbacks.</p> <pre><code>from pycrdt import TextEvent\n\ndef handle_changes(event: TextEvent):\n    # process the event\n    ...\n\ntext0_subscription_id = text0.observe(handle_changes)\n</code></pre> <p>The subscription ID can be used to unregister the callback later.</p> <pre><code>text0.unobserve(text0_subscription_id)\n</code></pre> <p>For container data types like <code>Array</code> and <code>Map</code>, it can be useful to observe changes that are deeply nested in the hierarchy. For instance, you may want to observe all changes that happen in <code>array0</code>, including changes in <code>map1</code>:</p> <pre><code>array0:\n  - 0\n  - \"foo\"\n  - \"bar\"\n  - map1:\n    \"baz\": 1\n</code></pre> <p>Using the <code>observe</code> method will only notify for changes happening at the top-level of the container, for instance when the value at index 2 is deleted, but not for changes happening in <code>map1</code>. Use the <code>observe_deep</code> method instead, with a callback that accepts a list of events.</p> <pre><code>from pycrdt import ArrayEvent\n\ndef handle_deep_changes(events: list[ArrayEvent]):\n    # process the events\n    ...\n\narray0_subscription_id = array0.observe_deep(handle_deep_changes)\n</code></pre> <p>Unregistering the callback is done with the same <code>unobserve</code> method.</p>"},{"location":"usage/#document-events","title":"Document events","text":"<p>Observing changes made to a document is mostly meant to send the changes to another document, usually over the wire to a remote machine. Changes can be serialized to binary by getting the event's <code>update</code>:</p> <pre><code>from pycrdt import TransactionEvent\n\ndef handle_doc_changes(event: TransactionEvent):\n    update: bytes = event.update\n    # send binary update on the wire\n\ndoc.observe(handle_doc_changes)\n</code></pre> <p>Changes can be applied to a remote document at the other end of the wire:</p> <pre><code># receive binary update from e.g. a WebSocket\nupdate: bytes\n\nremote_doc.apply_update(update)\n</code></pre>"},{"location":"usage/#undo-manager","title":"Undo manager","text":"<p>An undo manager allows to undo/redo changes to a set of shared types belonging to a document:</p> <pre><code>from pycrdt import Doc, Text, UndoManager\n\ndoc = Doc()\n\ntext = doc.get(\"text\", type=Text)\ntext += \"Hello\"\n\nundo_manager = UndoManager(doc=doc)\nundo_manager.expand_scope(text)\n\ntext += \", World!\"\nprint(str(text))\n# prints: \"Hello, World!\"\n\nundo_manager.undo()\nprint(str(text))\n# prints: \"Hello\"\n\nundo_manager.redo()\nprint(str(text))\n# prints: \"Hello, World!\"\n</code></pre> <p>Undoing a change doesn't remove the change from the document's history, but applies a change that is the opposite of the previous change.</p>"}]}