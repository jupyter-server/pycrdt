{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Pycrdt is a Python CRDT library that provides bindings for Yrs, the Rust port of the Yjs framework. </p> <p>Conflict-free Replicated Data Types (CRDTs) allow creating shared documents that can automatically merge changes made concurrently on different \"copies\" of the data. When the data lives on different machines, they make it possible to build distributed systems that work with local data, leaving the synchronization and conflict resolution with remote data to the CRDT algorithm, which ensures that all data replicas eventually converge to the same state.</p>"},{"location":"install/","title":"Install","text":"<p>Pycrdt can be installed through PyPI or conda-forge.</p>"},{"location":"install/#with-pip","title":"With <code>pip</code>","text":"<pre><code>pip install pycrdt\n</code></pre>"},{"location":"install/#with-micromamba","title":"With <code>micromamba</code>","text":"<p>We recommend using <code>micromamba</code> to manage <code>conda-forge</code> environments (see <code>micromamba</code>'s installation instructions). First create an environment, here called <code>my_env</code>, and activate it: <pre><code>micromamba create -n my_env\nmicromamba activate my_env\n</code></pre> Then install <code>pycrdt</code>.</p> <pre><code>micromamba install -c conda-forge pycrdt\n</code></pre>"},{"location":"install/#development-install","title":"Development install","text":"<p>You first need to clone the repository: <pre><code>git clone https://github.com/davidbrochart/pycrdt.git\ncd pycrdt\n</code></pre> We recommend working in a conda environment. In order to build <code>pycrdt</code>, you will need <code>pip</code> and the Rust compiler: <pre><code>micromamba create -n pycrdt-dev\nmicromamba activate pycrdt-dev\nmicromamba install -c conda-forge pip rust\n</code></pre> Then install <code>pycrdt</code> in editable mode: <pre><code>pip install -e .\n</code></pre> This will build the Rust extension using maturin. If you make changes to the Python code only, you don't need to recompile anything, changes will be reflected the next time you run the Python interpreter. If you make changes to the Rust code, you need to recompile it but you don't need to reinstall <code>pycrdt</code>, you can just re-build the Rust extension with: <pre><code># install maturin only once:\npip install maturin\n# build the Rust extension each time the Rust code changes:\nmaturin develop\n</code></pre></p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#quickstart","title":"Quickstart","text":"<p>Pycrdt offers the following shared data types:</p> <ul> <li><code>Text</code>: a type similar to a <code>str</code>.</li> <li><code>Array</code>: a type similar to a <code>list</code>.</li> <li><code>Map</code>: a type similar to a <code>dict</code>.</li> </ul> <p>You can initialize them with their Python built-in counterparts:</p> <pre><code>from pycrdt import Text, Array, Map\n\ntext0 = Text(\"Hello\")\narray0 = Array([0, \"foo\"])\nmap0 = Map({\"key0\": \"value0\"})\n</code></pre> <p>But they are pretty useless on their own. They are just placeholders waiting to be inserted in a shared document. Only then do they really become useful:</p> <pre><code>from pycrdt import Doc\n\ndoc = Doc()\ndoc[\"text0\"] = text0\ndoc[\"array0\"] = array0\ndoc[\"map0\"] = map0\n</code></pre> <p>Now you can operate on them as you would expect, for instance:</p> <pre><code>text0 += \", World!\"\narray0.append(\"bar\")\nmap0[\"key1\"] = \"value1\"\n</code></pre> <p>Note that an <code>Array</code> and a <code>Map</code> can hold other shared data types:</p> <pre><code>map1 = Map({\"baz\": 1})\narray1 = Array([5, 6, 7])\n\narray0.append(map1)\nmap0[\"key2\"] = array1\n</code></pre> <p>Every change to <code>doc</code> (a modified/added/deleted value) will generate an update in the form of a binary encoded data. You can listen to these updates and send them on the wire, so that they can be applied to a remote document.</p> <p>You can also listen to changes on the individual shared data types (<code>text0</code>, <code>array1</code>, etc.) by registering callbacks, that will be called with the change event(s), so that your application can react to data changes.</p> <p>We say that <code>text0</code>, <code>array0</code> and <code>map0</code> are root types of <code>doc</code>. When they got inserted into <code>doc</code>, we gave them a name. For instance, <code>text0</code> was inserted under <code>\"text0\"</code>. This is how a remote document will retrieve the root types of the document, after applying the received updates:</p> <pre><code>update = doc.get_update()\n\n# the (binary) update could travel on the wire to a remote machine:\n\nremote_doc = Doc()\nremote_doc.apply_update(update)\n\nremote_doc[\"text0\"] = text0 = Text()\nremote_doc[\"array0\"] = array0 = Array()\nremote_doc[\"map0\"] = map0 = Map()\n</code></pre> <p>You could say that there is nothing fancy here, it's just about encoding data changes so that they can be applied on another object. But this is where the magic of CRDTs comes into play. Their algorithm ensures that if some changes are done concurrently on different objects representing the same data (for instance on different machines), applying the changes will lead to the same data on all objects. Without such algorithms, this property doesn't hold due to the fact that changes depend on the order in which they are applied, and that they take time to travel on the wire.</p> <p>The most common example is inserting a different character on a text editor on two machines. Say we start with a blank page on both editors, and the user on machine A inserts \"a\" at the same time the user on machine B inserts \"b\". After receiving the other user's update, if no special care is taken, machine A will show \"ba\" and machine B will show \"ab\". In other words, their document states will diverge, and thus users won't collaborate on the same document anymore. CRDTs ensure that documents don't diverge, their shared documents will eventually have the same state. It will arbitrary be \"ab\" or \"ba\", but it will be the same on both machines.</p>"},{"location":"usage/#transactions","title":"Transactions","text":"<p>Every change to a shared data happens in a document transaction. When no current transaction exists, an implicit transaction is created. Grouping multiple changes in a single transaction makes them atomic: they will appear as done simultaneously rather than sequentially.</p> <pre><code>with doc.transaction():\n    text0 += \", World!\"\n    array0.append(\"bar\")\n    map0[\"key1\"] = \"value1\"\n</code></pre> <p>Transactions can be nested: when a transaction is created inside another one, changes will be made in the outer transaction. In the following example, all changes are made in transaction <code>t0</code>.</p> <pre><code>with doc.transaction() as t0:\n    text0 += \", World!\"\n    with doc.transaction() as t1:\n        array0.append(\"bar\")\n        with doc.transaction() as t2:\n            map0[\"key1\"] = \"value1\"\n</code></pre>"},{"location":"usage/#events","title":"Events","text":""},{"location":"usage/#shared-data-events","title":"Shared data events","text":"<p>Changes to shared data can be observed in order to react on them. For instance, if a character is inserted in a <code>Text</code> data, a text editor should insert the character in the text shown to the user. This is done by registering callbacks.</p> <pre><code>from pycrdt import TextEvent\n\ndef handle_changes(event: TextEvent):\n    # process the event\n    ...\n\ntext0_subscription_id = text0.observe(handle_changes)\n</code></pre> <p>The subscription ID can be used to unregister the callback later.</p> <pre><code>text0.unobserve(text0_subscription_id)\n</code></pre> <p>For container data types like <code>Array</code> and <code>Map</code>, it can be useful to observe changes that are deeply nested in the hierarchy. For instance, you may want to observe all changes that happen in <code>array0</code>, including changes in <code>map1</code>:</p> <pre><code>array0:\n  - 0\n  - \"foo\"\n  - \"bar\"\n  - map1:\n    \"baz\": 1\n</code></pre> <p>Using the <code>observe</code> method will only notify for changes happening at the top-level of the container, for instance when the value at index 2 is deleted, but not for changes happening in <code>map1</code>. Use the <code>observe_deep</code> method instead, with a callback that accepts a list of events.</p> <pre><code>from pycrdt import ArrayEvent\n\ndef handle_deep_changes(events: list[ArrayEvent]):\n    # process the events\n    ...\n\narray0_subscription_id = array0.observe_deep(handle_deep_changes)\n</code></pre> <p>Unregistering the callback is done with the same <code>unobserve</code> method.</p>"},{"location":"usage/#document-events","title":"Document events","text":"<p>Observing changes made to a document is mostly meant to send the changes to another document, usually over the wire to a remote machine. Changes can be serialized to binary by calling <code>get_update()</code> on the event:</p> <pre><code>from pycrdt import TransactionEvent\n\ndef handle_doc_changes(event: TransactionEvent):\n    update: bytes = event.get_update()\n    # send binary update on the wire\n\ndoc.observe(handle_doc_changes)\n</code></pre> <p>Changes can be applied to a remote document at the other end of the wire:</p> <pre><code># receive binary update from e.g. a WebSocket\nupdate: bytes\n\nremote_doc.apply_update(update)\n</code></pre>"}]}